---
title: Route-based Content Fetching
description: Automatically fetch page content based on the current route without manual composable calls. Zero-config content fetching with smart caching.
navigation:
  icon: i-lucide-activity
---

# Route-based Content Fetching

Route-based Content Fetching provides automatic content loading for pages without requiring manual composable calls in every component, while maintaining flexibility through configuration.

## Benefits

- ‚úÖ **Zero boilerplate** - Content automatically available based on URL
- ‚úÖ **Smart caching** - Efficient content deduplication and storage  
- ‚úÖ **Flexible routing** - Support for complex route patterns
- ‚úÖ **Error handling** - Configurable error modes (silent, log, throw)
- ‚úÖ **TypeScript support** - Full type safety with generics
- ‚úÖ **Backward compatible** - Works alongside existing manual fetching

## Quick Setup

### 1. Enable Auto-fetch

Add auto-fetch configuration to your `nuxt.config.ts`:

```typescript [nuxt.config.ts]
export default defineNuxtConfig({
  modules: ['nuxt-contentstack'],
  
  'nuxt-contentstack': {
    // ... other configuration
    
    // Route-based content fetching
    autoFetch: {
      enabled: true, // Enable the middleware
      
      // Routes to include (optional - if empty, all routes are processed)
      include: [
        '/', // Homepage
        '/about', // Specific routes
        '/blog/*', // Wildcard patterns
        '/products/**', // Deep wildcard patterns
      ],
      
      // Routes to exclude
      exclude: ['/admin/**', '/api/**', '/_nuxt/**'],
      
      // Map routes to content types
      contentTypeMapping: {
        '/': 'page', // Homepage uses 'page' content type
        '/blog/*': 'article', // Blog routes use 'article' content type
        '/products/*': 'product', // Product routes use 'product' content type
        default: 'page', // Fallback content type
      },
      
      // Additional options
      options: {
        locale: 'en-us',
        includeReferences: ['author', 'category'], // References to include
        includeFallback: true,
        cacheKey: 'auto-fetch',
        errorHandling: 'silent', // 'silent' | 'throw' | 'log'
      },
    },
  },
})
```

### 2. Use in Components

Access auto-fetched content in your pages:

```vue [pages/index.vue]
<script setup>
// No manual composable calls needed!
const { content, isLoaded, meta, refresh } = useAutoFetchedContent<Page>()
</script>

<template>
  <div v-if="isLoaded && content">
    <h1>{{ content.title }}</h1>
    <p>{{ content.description }}</p>

    <!-- Content is automatically available based on current route -->
    <div v-html="content.rich_text" />

    <!-- Metadata about the fetched content -->
    <div class="meta">
      <p>Content Type: {{ meta.contentType }}</p>
      <p>UID: {{ meta.uid }}</p>
      <p>Fetched: {{ meta.fetchedAt }}</p>
    </div>

    <!-- Manual refresh if needed -->
    <button @click="refresh">Refresh Content</button>
  </div>
</template>
```

## How It Works

1. **üöÄ Middleware runs** - On every route change, the auto-fetch middleware activates
2. **üîç URL matching** - URL is matched against your include/exclude patterns  
3. **üó∫Ô∏è Content type determination** - Content type is determined from your mapping configuration
4. **üì• Content fetching** - Content is fetched from Contentstack using the URL field
5. **‚úÖ Data availability** - Data becomes available via `useAutoFetchedContent()` in your components

This eliminates the need for manual `useGetEntryByUrl()` calls in every page component!

## Route Patterns

### Pattern Types

::callout{icon="i-lucide-info"}
Auto-fetch supports flexible route patterns to match your site structure.
::

- **Exact matches**: `/about` matches only `/about`
- **Single wildcard**: `/blog/*` matches `/blog/post-1` but not `/blog/category/post-1`  
- **Deep wildcard**: `/blog/**` matches all nested routes under `/blog/`

### Example Patterns

```typescript
{
  include: [
    '/', // Homepage only
    '/about', // Exact about page
    '/blog/*', // Blog posts (single level)
    '/products/**', // All product pages (any depth)
    '/docs/**/guide', // Any guide under docs
  ],
  exclude: [
    '/admin/**', // All admin routes
    '/api/**', // All API routes
    '/_nuxt/**', // Nuxt internal routes
  ]
}
```

## Advanced Usage

### Get Content for Specific Routes

Access content for other routes from any component:

```vue
<script setup>
const { getContentFor } = useAutoFetchedContent()

// Get content for other routes
const aboutContent = getContentFor('/about')
const blogContent = getContentFor('/blog/my-post', 'article')
</script>
```

### Conditional Auto-fetch

Control auto-fetch behavior with options:

```typescript
const { content, isLoaded, meta, refresh } = useAutoFetchedContent<Page>({
  contentType: 'page', // Optional: filter by content type
  fallbackToManual: false, // Optional: fallback to manual fetching
})
```

### Manual Refresh

Trigger content refresh when needed:

```vue
<script setup>
const { refresh } = useAutoFetchedContent()

// Refresh content programmatically
const handleRefresh = async () => {
  await refresh()
}
</script>
```

## Configuration Options

### Auto-fetch Configuration

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `enabled` | `boolean` | `false` | Enable or disable auto-fetch middleware |
| `include` | `string[]` | `[]` | Route patterns to include (empty = all routes) |
| `exclude` | `string[]` | `['/admin/**', '/api/**', '/_nuxt/**']` | Route patterns to exclude |
| `contentTypeMapping` | `object` | `{ default: 'page' }` | Map routes to content types |
| `options` | `object` | See below | Additional fetch options |

### Options Configuration

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `locale` | `string` | `'en-us'` | Content locale |
| `includeReferences` | `string[]` | `[]` | Reference fields to include |
| `includeFallback` | `boolean` | `true` | Include fallback content |
| `cacheKey` | `string` | `'auto-fetch'` | Cache key prefix |
| `errorHandling` | `'silent' \| 'log' \| 'throw'` | `'silent'` | Error handling mode |

## Error Handling

Auto-fetch provides flexible error handling modes:

### Silent Mode (Default)

```typescript
{
  errorHandling: 'silent' // Errors are swallowed, content remains null
}
```

### Log Mode

```typescript
{
  errorHandling: 'log' // Errors are logged to console, content remains null
}
```

### Throw Mode

```typescript
{
  errorHandling: 'throw' // Errors are thrown and can be caught by error boundaries
}
```

## Performance & Caching


### Automatic Caching

- **Smart deduplication** - Same content is never fetched twice
- **Route-based keys** - Content cached per route/content type combination
- **Nuxt integration** - Uses Nuxt's built-in caching system

### Cache Control

Control caching behavior with custom cache keys:

```typescript
{
  options: {
    cacheKey: 'my-custom-cache', // Custom cache key prefix
  }
}
```

## TypeScript Support

Auto-fetch provides full TypeScript support with generic types:

```typescript
interface Page {
  title: string
  description: string
  content: string
  // ... your page structure
}

// Fully typed content
const { content, isLoaded } = useAutoFetchedContent<Page>()

if (isLoaded.value && content.value) {
  // content.value is fully typed as Page
  console.log(content.value.title) // ‚úÖ TypeScript knows this is a string
}
```

## Debugging

Enable debug mode to see auto-fetch configuration:

```typescript [nuxt.config.ts]
export default defineNuxtConfig({
  'nuxt-contentstack': {
    debug: true, // Shows auto-fetch config in terminal
    autoFetch: {
      enabled: true,
      // ... configuration
    }
  }
})
```

Debug output shows your complete auto-fetch configuration:

```json
{
  "autoFetch": {
    "enabled": true,
    "include": ["/"],
    "exclude": ["/admin/**", "/api/**", "/_nuxt/**"],
    "contentTypeMapping": {
      "default": "page",
      "/": "page"
    },
    "options": {
      "locale": "en-us",
      "includeReferences": [],
      "includeFallback": true,
      "cacheKey": "auto-fetch",
      "errorHandling": "log"
    }
  }
}
```

## Migration Guide

### From Manual Fetching

**Before** (manual composable calls):

```vue
<script setup>
// Manual fetching in every component
const { data: page } = await useGetEntryByUrl<Page>({
  contentTypeUid: 'page',
  url: useRoute().path,
})
</script>

<template>
  <div v-if="page">
    <h1>{{ page.title }}</h1>
  </div>
</template>
```

**After** (auto-fetch):

```vue
<script setup>
// No manual calls needed!
const { content: page, isLoaded } = useAutoFetchedContent<Page>()
</script>

<template>
  <div v-if="isLoaded && page">
    <h1>{{ page.title }}</h1>
  </div>
</template>
```

### Gradual Migration

Auto-fetch is **backward compatible** - you can enable it gradually:

1. **Start with specific routes** - Use `include` to enable only for certain pages
2. **Test thoroughly** - Verify content fetching works as expected  
3. **Expand coverage** - Add more routes to `include` over time
4. **Keep manual fetching** - Existing `useGetEntryByUrl` calls continue to work

## Examples

### Blog Site

```typescript [nuxt.config.ts]
{
  autoFetch: {
    enabled: true,
    include: [
      '/', // Homepage
      '/blog/*', // Blog posts
      '/about', // About page
    ],
    contentTypeMapping: {
      '/': 'homepage',
      '/blog/*': 'blog_post',
      '/about': 'page',
      default: 'page'
    }
  }
}
```

### E-commerce Site

```typescript [nuxt.config.ts]
{
  autoFetch: {
    enabled: true,
    include: [
      '/products/**', // All product pages
      '/categories/*', // Category pages
    ],
    exclude: [
      '/checkout/**', // Exclude checkout flow
      '/account/**', // Exclude user account
    ],
    contentTypeMapping: {
      '/products/*': 'product',
      '/categories/*': 'category',
      default: 'page'
    },
    options: {
      includeReferences: ['brand', 'category', 'related_products']
    }
  }
}
```